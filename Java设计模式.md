# Java设计模式

目的：代码重用性、可读性、可扩展性、可靠性、使程序呈现高内聚，低耦合的特点。

## 七大设计原则

### 单一职责

**一个类应该只负责一项职责**

1、降低类的复杂度，一个类只负责一项职责。

2、提高类的可读性，可维护性

3、降低变更引起的风险

4、通常情况下，我们应当遵守**单一职责原则**，只有逻辑足够简单，才可以在代码级别违反单一职责原则，只有类中方法数量足够少，可以在方法级别保持单一职责原则。

### 接口隔离

客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。

### 依赖倒置

1、高层模块不应该依赖底层模块，二者都应该依赖其抽象

2、抽象不应该依赖细节，细节应该依赖细节

3、依赖倒置的中心思想是面向接口变成

4、基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类

5、使用接口或抽象类的目的是制定好的规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。

依赖关系传递的三种方式

1、接口传递            2、构造方法传递            3、setter方式传递

### 里氏替换

任何基类可以出现的地方，子类一定可以出现

在使用继承时，子类中尽量不要重写父类的方法。

若子类无意重写了父类方法，出现错误，改性方案通用的做法是使原来的父类和子类都继承一个更通俗的基类。

### 开闭原则

1、开闭原则是编程中最基础、最重要的设计原则

2、一个软件实体如类，模块和函数应该对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节。

3、当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。

4、编程中遵循其它原则， 以及使用设计模式的目的就是遵循**开闭原则**

### 迪米特法则

1、一个对象应该对其他对象保持最少的了解

2、类与类关系越密切，耦合度越大

3、迪米特法则又叫最少知道法则，即一个类对自己依赖的类知道的越少越好

4、迪米特法则还有个更简单的定义：只与**直接的朋友通信**

迪米特法则的核心是降低类之间的耦合，但是注意，由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完全没有依赖关系

### 合成复用原则

原则是尽量使用合成/聚合的方式，而不是使用继承

## 设计原则核心思想

1、找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。

2、针对接口编程，而不是针对实现编程

3、为了交互对象之间的松耦合设计而努力

## UML基本介绍

UML（统一建模语言）是一种用于软件系统分析和设计的语言工具。

![image-20191216124421669](img/image-20191216124421669.png)

UML分类

1、例图    2、静态结构图：**类图**，对象图、包图、组件图、部署图  3、动态行为图

说明：类图是描述类与类之间的关系的，是UML图中最核心的



### 类图介绍

类图用于描述系统中的类（对象）本身的组成和类（对象）之间的各种静态关系，主要有依赖，泛化（继承）、实现、关联、聚合与组合。

#### 依赖关系

只要是在类中用到了对方，那么他们之间就存在依赖关系，如果没有对方，连编译都通过不了

1、类中用到了对方  2、如果是类的成员属性  3、如果是方法的返回类型   4、是方法接收的参数类型   5、方法中使用到

#### 泛化关系

泛化关系实际就是继承关系，它是依赖关系的特例

#### 实现关系

A类实现B类，即存在实现关系，也是依赖关系的特例

#### 关联关系

就是类与类之间的联系，也是依赖关系的特例。关联具有导航性，即双向关系或单向关系。

#### 聚合关系

聚合关系表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例。通常通过setter方法

#### 组合关系

组合关系也是整体和部分的关系，但是整体和部分不可分开。

## 设计模式分类

1、创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式

2、结构型模式：适配器模式、桥接模式、装饰者模式、组合模式、外观模式、享元模式、代理模式

3、行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式

### 单例模式

**1）饿汉式（静态常量）**

类装载时完成实例化，避免线程同步问题，易造成内存浪费。

**2）饿汉式（静态代码块）**

优缺点与上面一样

**3）懒汉式（线程不安全）**

线程不安全

4）懒汉式（线程安全，同步方法）

效率低，每个线程获得实例都需要进行同步

5）懒汉式（线程安全，同步代码块）

实际上并不能解决线程安全问题

**6）双重检查**

完美解决上述问题

**7）静态内部类**

类加载时不会初始化，需要实例化时，调用getInstance方法，才会装载到该类，完成实例化

**8）枚举**

推荐使用

![image-20191216201603904](img/image-20191216201603904.png)



### 工厂设计模式

简单工厂模式是由一个工厂对象决定出创建出哪一种产品的实例，封装了实例化对象的行为。

工厂方法模式将对象的实例化推迟到子类。

抽象工厂模式：整合了简单工厂模式和工厂方法模式，将工厂抽象成两层，AbsFactory和具体实现的工厂子类。动机是为了实现一系列相互依赖的对象的创建工作。即提供一个接口，让该接口负责创建以系列”相关或者相互依赖的对象“，无需指定他们具体的类。

抽象工厂模式要点总结：

![image-20191216230936241](../AppData/Roaming/Typora/typora-user-images/image-20191216230936241.png)

### 原型模式

创建具有相同属性的对象，传统方法较好理解，简单易操作，但是创建对象总是需要重新获取原始对象属性，效率低，总是需要初始化对象，而不是动态地获得对象运行时状态，不够灵活。

改进思路：Object有clone()方法，实现clone的Java类需实现一个接口Cloneable，表示该类能够复制且具有复制的能力=》原型模式

使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。允许一个对象再创建另一个可定制的对象，无需知道细节。工作原理是将一个原型对象传给那个要发动创建的类，这个要发动创建的类通过请求原型对象拷贝它们自己来实施创建。即对象.clone()

Spring中原型bean的创建，就是原型模式的运用

浅拷贝：默认的clone方法进行浅拷贝，对数据类型是引用的类型直接传递其引用值，而不会新创建一个引用对象。

深拷贝：对数据类型是引用的类型也要进行拷贝，实现方式主要有重写clone方法或通过对象的序列化来实现。

缺点是需要给每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源码，违背了ocp原则。

### 建造者模式

普通方法将产品和创建产品的过程封装在一起，耦合性较强。

改进思路：将产品和产品的建造过程解耦=》建造者模式

将对象的表示和构建相分离，使得同样的构建过程可以创建不同的表示

![image-1576566516622](img/image-1576566516622.png)

#### 抽象工厂模式对比建造者模式

抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可，而建造者模式是要求按照指定的蓝图构造产品，它的主要目的是通过组装零配件而生产一个新产品。

### 适配器模式

将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作，别名为包装器（wrapper），主要分为：类适配器，对象适配器，接口适配器。

**对象适配器**：持有被适配器的类而不继承，实现dst类接口。

接口适配器：用一个抽象类实现接口全部方法，空实现，子类选择性覆盖。

### 桥接模式

用一个中介对象来封装一系列对象交互，该模式使得对象不需要显示的引用，从而使其耦合松散，可以独立地改变它们之间的交互。

主要解决双向的关联关系

将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变

![1576581019721](img/1576581019721.png)

### 装饰者模式

动态地将新功能附加到对象上。一个类既继承被装饰类，被装饰类又作为其属性。

自己理解：继承了被装饰类，自身有装饰类属性，通过覆盖有意义的方法对其进行增强。即增强了被装饰类，使代码重用。

### 组合模式

创建了对象组的树形结构，将对象组合成树状结构以表示“整体部分”的层次关系

解决这样的问题：当我们要处理的对象可以生成一颗树形结构，而我们要对树上的节点和叶子节点进行操作时，它能够提供一致的方式，而不用考虑它是节点还是叶子节点

### 代理模式

为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。

被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象。

主要有三类：静态代理，动态代理，cglib代理（在内存动态的创建代理，而不需要实现接口）

#### 静态代理

静态代理在使用时，需要定义接口或者父类，被代理对象（即目标对象）与代理对象一起实现相同的接口或者是继承相同父类。

优点：在不修改目标对象的功能前提下，能通过代理对象对目标功能的扩展

缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类，一旦接口增加方法，需要维护。

#### 动态代理

在运行时，动态创建一组指定的接口的实现类对象（在运行时，创建了实现了指定的一组接口的对象）

代理对象不需要实现接口，但是目标对象要实现接口，否则不能代理，代理对象的生成是利用JDK的API，动态的在内存中构建代理对象。

~~~java
        /**
         * 1:classLoader 用于加载生成的代理对象到方法区
         * 2:interfaces 要让代理对象实现的接口
         * 3:invocationHandler 调用处理器,代理对象调用任何方法都会调用其invoke方法
         */
Proxy.newProxyInstance(ClassLoader classloader,Class<?>[] interfaces,InvocationHandler h)
~~~

#### Cglib代理

即使目标对象没有实现相应接口，也可以进行代理

### 模板模式

### 状态模式

它主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题，状态和行为是一一对应的，状态之间可以相互转换

当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类

优化if/else

